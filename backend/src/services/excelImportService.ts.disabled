import * as XLSX from 'xlsx';
import { PrismaClient, $Enums } from '@prisma/client';
import MigrationValidator, { ValidationError } from './migrationValidator';
import logger from '../utils/logger';
import { prisma } from './prismaClient';

export interface ParsedExcelData {
  projects: Array<Record<string, unknown>>;
  teamMembers: Array<Record<string, unknown>>;
  tasks: Array<Record<string, unknown>>;
  costs: Array<Record<string, unknown>>;
  kpis: Array<Record<string, unknown>>;
  configuration: Array<Record<string, unknown>>;
}

export interface ImportResult {
  success: boolean;
  message: string;
  imported?: {
    projects: number;
    users: number;
    tasks: number;
    costs: number;
    kpis: number;
  };
  errors?: ValidationError[];
  warnings?: ValidationError[];
}

export class ExcelImportService {
  private prisma: PrismaClient;
  private validator: MigrationValidator;
  private importReport: Partial<ImportReport> = {};

  constructor() {
    this.prisma = prisma;
    this.validator = new MigrationValidator();
  }

  async parseExcelFile(buffer: Buffer): Promise<ParsedExcelData> {
    try {
      const workbook = XLSX.read(buffer, { type: 'buffer' });

      const data: ParsedExcelData = {
        projects: [],
        teamMembers: [],
        tasks: [],
        costs: [],
        kpis: [],
        configuration: [],
      };

      if (workbook.SheetNames.includes('Projects List')) {
        const sheet = workbook.Sheets['Projects List'];
        data.projects = XLSX.utils.sheet_to_json(sheet);
      }

      if (workbook.SheetNames.includes('Team members Data')) {
        const sheet = workbook.Sheets['Team members Data'];
        data.teamMembers = XLSX.utils.sheet_to_json(sheet);
      }

      if (workbook.SheetNames.includes('Tasks')) {
        const sheet = workbook.Sheets['Tasks'];
        data.tasks = XLSX.utils.sheet_to_json(sheet);
      }

      if (workbook.SheetNames.includes('Project Costs')) {
        const sheet = workbook.Sheets['Project Costs'];
        data.costs = XLSX.utils.sheet_to_json(sheet);
      }

      if (workbook.SheetNames.includes('Employees KPIs')) {
        const sheet = workbook.Sheets['Employees KPIs'];
        data.kpis = XLSX.utils.sheet_to_json(sheet);
      }

      if (workbook.SheetNames.includes('List')) {
        const sheet = workbook.Sheets['List'];
        data.configuration = XLSX.utils.sheet_to_json(sheet);
      }

      logger.info('Excel file parsed successfully', {
        sheets: workbook.SheetNames,
        projectCount: data.projects.length,
        userCount: data.teamMembers.length,
        taskCount: data.tasks.length,
      });

      return data;
    } catch (error) {
      logger.error('Failed to parse Excel file', { error });
      throw new Error(`Failed to parse Excel file: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  async validateExcelData(data: ParsedExcelData): Promise<ValidationError[]> {
    const allErrors: ValidationError[] = [];

    for (let i = 0; i < data.projects.length; i++) {
      const result = this.validator.validateProjectData(data.projects[i], i + 1);
      allErrors.push(...result.errors);
    }

    for (let i = 0; i < data.teamMembers.length; i++) {
      const result = this.validator.validateUserData(data.teamMembers[i], i + 1);
      allErrors.push(...result.errors);
    }

    for (let i = 0; i < data.tasks.length; i++) {
      const result = this.validator.validateTaskData(data.tasks[i], i + 1);
      allErrors.push(...result.errors);
    }

    for (let i = 0; i < data.costs.length; i++) {
      const result = this.validator.validateCostData(data.costs[i], i + 1);
      allErrors.push(...result.errors);
    }

    for (let i = 0; i < data.kpis.length; i++) {
      const result = this.validator.validateKPIData(data.kpis[i], i + 1);
      allErrors.push(...result.errors);
    }

    if (allErrors.length > 0) {
      logger.warn('Excel validation found errors', { errorCount: allErrors.length });
    }

    return allErrors;
  }

  async importData(data: ParsedExcelData): Promise<ImportResult> {
    const startTime = Date.now();

    try {
      logger.info('Starting data import transaction');

      const result = await this.prisma.$transaction(async (tx) => {
        let importedProjects = 0;
        let importedUsers = 0;
        let importedTasks = 0;
        let importedCosts = 0;
        let importedKpis = 0;

        for (const projectData of data.projects) {
          const client = await tx.client.upsert({
            where: { name: projectData.clientName as string },
            create: { name: projectData.clientName as string },
            update: {},
          });

          await tx.project.create({
            data: {
              clientId: client.id,
              name: `${projectData.clientName as string} Project`,
              contractCode: projectData.contractCode as string,
              contractSigningDate: new Date(projectData.contractSigningDate as string),
              builtUpArea: Number(projectData.builtUpArea),
              licenseType: projectData.licenseType as string,
              projectType: projectData.projectType as string,
              requirements: projectData.requirements as string,
              startDate: new Date(projectData.startDate as string),
              estimatedEndDate: new Date(projectData.estimatedEndDate as string),
            },
          });

          importedProjects++;
        }

        for (const userData of data.teamMembers) {
          await tx.user.upsert({
            where: { email: userData.email as string },
            create: {
              email: userData.email as string,
              name: userData.name as string,
              role: 'TEAM_MEMBER',
              position: userData.position as string,
              region: userData.region as string,
              grade: userData.grade as string,
              level: userData.level as string,
              monthlyCost: userData.monthlyCost ? Number(userData.monthlyCost) : undefined,
            },
            update: {},
          });

          importedUsers++;
        }

        for (const taskData of data.tasks) {
          const project = await tx.project.findUnique({
            where: { contractCode: taskData.projectCode as string },
          });

          if (!project) {
            throw new Error(`Project not found for contract code: ${taskData.projectCode}`);
          }

          let phase = await tx.phase.findFirst({
            where: {
              projectId: project.id,
              name: taskData.phase === 'Studies' ? $Enums.PhaseName.STUDIES : $Enums.PhaseName.DESIGN,
            },
          });

          if (!phase) {
            phase = await tx.phase.create({
              data: {
                projectId: project.id,
                name: taskData.phase === 'Studies' ? $Enums.PhaseName.STUDIES : $Enums.PhaseName.DESIGN,
                startDate: project.startDate,
              },
            });
          }

          await tx.task.create({
            data: {
              phaseId: phase.id,
              code: taskData.taskCode as string,
              description: taskData.description as string,
              duration: Number(taskData['Duration (Days)']),
            },
          });

          importedTasks++;
        }

        for (const costData of data.costs) {
          const project = await tx.project.findUnique({
            where: { contractCode: costData.projectCode as string },
          });

          if (!project) {
            throw new Error(`Project not found for contract code: ${costData.projectCode}`);
          }

          const user = await tx.user.findUnique({
            where: { email: costData.employeeEmail as string },
          });

          if (!user) {
            throw new Error(`User not found for email: ${costData.employeeEmail}`);
          }

          const phase = await tx.phase.findFirst({
            where: { projectId: project.id },
          });

          if (!phase) {
            throw new Error(`Phase not found for project: ${project.contractCode}`);
          }

          await tx.costEntry.create({
            data: {
              projectId: project.id,
              phaseId: phase.id,
              employeeId: user.id,
              period: new Date(`${costData.period}-01`),
              costAmount: Number(costData.costAmount),
            },
          });

          importedCosts++;
        }

        for (const kpiData of data.kpis) {
          const project = await tx.project.findUnique({
            where: { contractCode: kpiData.projectCode as string },
          });

          if (!project) {
            throw new Error(`Project not found for contract code: ${kpiData.projectCode}`);
          }

          const user = await tx.user.findUnique({
            where: { email: kpiData.employeeEmail as string },
          });

          if (!user) {
            throw new Error(`User not found for email: ${kpiData.employeeEmail}`);
          }

          const phase = await tx.phase.findFirst({
            where: { projectId: project.id },
          });

          if (!phase) {
            throw new Error(`Phase not found for project: ${project.contractCode}`);
          }

          await tx.kPIEntry.create({
            data: {
              projectId: project.id,
              phaseId: phase.id,
              employeeId: user.id,
              delayedDays: kpiData.delayedDays ? Number(kpiData.delayedDays) : 0,
              clientModifications: kpiData.clientModifications ? Number(kpiData.clientModifications) : 0,
              technicalMistakes: kpiData.technicalMistakes ? Number(kpiData.technicalMistakes) : 0,
            },
          });

          importedKpis++;
        }

        return {
          projects: importedProjects,
          users: importedUsers,
          tasks: importedTasks,
          costs: importedCosts,
          kpis: importedKpis,
        };
      });

      const duration = Date.now() - startTime;
      logger.info('Data import completed successfully', { result, duration });

      return {
        success: true,
        message: 'Data imported successfully',
        imported: result,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error('Data import failed', { error, duration });

      return {
        success: false,
        message: `Import failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }

  generateImportReport(
    fileName: string,
    errors: ValidationError[],
    warnings: ValidationError[],
    duration: number,
    successfulRows: number,
    totalRows: number
  ): ImportReport {
    const failedRows = errors.length;
    const warningCount = warnings.length;

    const report: ImportReport = {
      fileName,
      totalRows,
      successfulRows,
      failedRows,
      errors,
      warnings,
      duration,
      timestamp: new Date(),
    };

    logger.info('Import report generated', {
      fileName,
      totalRows,
      successfulRows,
      failedRows,
      warningCount,
      duration,
    });

    return report;
  }

  formatErrorsForDisplay(errors: ValidationError[]): string {
    if (errors.length === 0) {
      return 'No errors found.';
    }

    return errors
      .map(
        (error, index) =>
          `${index + 1}. Row ${error.row || 'N/A'} - ${error.field}: ${error.message}`
      )
      .join('\n');
  }

  groupErrorsByField(errors: ValidationError[]): Record<string, ValidationError[]> {
    const grouped: Record<string, ValidationError[]> = {};

    for (const error of errors) {
      if (!grouped[error.field]) {
        grouped[error.field] = [];
      }
      grouped[error.field].push(error);
    }

    return grouped;
  }

  getErrorSummary(errors: ValidationError[]): {
    totalErrors: number;
    uniqueFields: string[];
    criticalErrors: ValidationError[];
    warningErrors: ValidationError[];
  } {
    const uniqueFields = Array.from(new Set(errors.map(e => e.field)));
    const criticalErrors = errors.filter(e => e.severity !== 'warning');
    const warningErrors = errors.filter(e => e.severity === 'warning');

    return {
      totalErrors: errors.length,
      uniqueFields,
      criticalErrors,
      warningErrors,
    };
  }
}

export interface ImportReport {
  fileName: string;
  totalRows: number;
  successfulRows: number;
  failedRows: number;
  errors: ValidationError[];
  warnings: ValidationError[];
  duration: number;
  timestamp: Date;
}

export default ExcelImportService;
